{"ast":null,"code":"\"use strict\"; // Copyright 2014-2016, Google, Inc.\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _classCallCheck = require(\"/Users/brianroytman/Dev/300Records_Dashboard/nodejs-frontend-react-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/brianroytman/Dev/300Records_Dashboard/nodejs-frontend-react-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/brianroytman/Dev/300Records_Dashboard/nodejs-frontend-react-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/brianroytman/Dev/300Records_Dashboard/nodejs-frontend-react-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/brianroytman/Dev/300Records_Dashboard/nodejs-frontend-react-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _regeneratorRuntime = require(\"/Users/brianroytman/Dev/300Records_Dashboard/nodejs-frontend-react-dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar google_auth_library_1 = require(\"google-auth-library\");\n\nvar qs = require(\"qs\");\n\nvar stream = require(\"stream\");\n\nvar urlTemplate = require(\"url-template\");\n\nvar uuid = require(\"uuid\");\n\nvar isbrowser_1 = require(\"./isbrowser\"); // tslint:disable-next-line no-var-requires\n\n\nvar pkg = require('../../package.json');\n\nfunction isReadableStream(obj) {\n  return obj instanceof stream.Readable && typeof obj._read === 'function';\n}\n\nfunction getMissingParams(params, required) {\n  var missing = new Array();\n  required.forEach(function (param) {\n    // Is the required param in the params object?\n    if (params[param] === undefined) {\n      missing.push(param);\n    }\n  }); // If there are any required params missing, return their names in array,\n  // otherwise return null\n\n  return missing.length > 0 ? missing : null;\n}\n\nfunction createAPIRequest(parameters, callback) {\n  if (callback) {\n    createAPIRequestAsync(parameters).then(function (r) {\n      return callback(null, r);\n    }, callback);\n  } else {\n    return createAPIRequestAsync(parameters);\n  }\n}\n\nexports.createAPIRequest = createAPIRequest;\n\nfunction createAPIRequestAsync(parameters) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var params, options, topOptions, media, resource, authClient, defaultMime, headers, missingParams, multipart, boundary, finale, rStream, pStream, isStream, _i, _multipart, part, preamble, directives, userAgent, mergedOptions;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            params = parameters.params;\n            options = Object.assign({}, parameters.options); // Create a new params object so it can no longer be modified from outside\n            // code Also support global and per-client params, but allow them to be\n            // overriden per-request\n\n            topOptions = parameters.context.google ? parameters.context.google._options.params : {};\n            params = Object.assign({}, // New base object\n            topOptions, // Global params\n            parameters.context._options.params, // Per-client params\n            params // API call params\n            );\n            media = params.media || {};\n            /**\n             * In a previous version of this API, the request body was stuffed in a field\n             * named `resource`.  This caused lots of problems, because it's not uncommon\n             * to have an actual named parameter required which is also named `resource`.\n             * This mean that users would have to use `resource_` in those cases, which\n             * pretty much nobody figures out on their own. The request body is now\n             * documented as being in the `requestBody` property, but we also need to keep\n             * using `resource` for reasons of back-compat. Cases that need to be covered\n             * here:\n             * - user provides just a `resource` with a request body\n             * - user provides both a `resource` and a `resource_`\n             * - user provides just a `requestBody`\n             * - user provides both a `requestBody` and a `resource`\n             */\n\n            resource = params.requestBody ? params.requestBody : params.resource;\n\n            if (!params.requestBody && params.resource) {\n              delete params.resource;\n            }\n\n            delete params.requestBody;\n            authClient = params.auth || parameters.context._options.auth || (parameters.context.google ? parameters.context.google._options.auth : null);\n            defaultMime = typeof media.body === 'string' ? 'text/plain' : 'application/octet-stream';\n            delete params.media;\n            delete params.auth; // Grab headers from user provided options\n\n            headers = params.headers || {};\n            delete params.headers; // Un-alias parameters that were modified due to conflicts with reserved names\n\n            Object.keys(params).forEach(function (key) {\n              if (key.slice(-1) === '_') {\n                var newKey = key.slice(0, -1);\n                params[newKey] = params[key];\n                delete params[key];\n              }\n            }); // Check for missing required parameters in the API request\n\n            missingParams = getMissingParams(params, parameters.requiredParams);\n\n            if (!missingParams) {\n              _context.next = 18;\n              break;\n            }\n\n            throw new Error('Missing required parameters: ' + missingParams.join(', '));\n\n          case 18:\n            // Parse urls\n            if (options.url) {\n              options.url = urlTemplate.parse(options.url).expand(params);\n            }\n\n            if (parameters.mediaUrl) {\n              parameters.mediaUrl = urlTemplate.parse(parameters.mediaUrl).expand(params);\n            } // When forming the querystring, override the serializer so that array\n            // values are serialized like this:\n            // myParams: ['one', 'two'] ---> 'myParams=one&myParams=two'\n            // This serializer also encodes spaces in the querystring as `%20`,\n            // whereas the default serializer in gaxios encodes to a `+`.\n\n\n            options.paramsSerializer = function (params) {\n              return qs.stringify(params, {\n                arrayFormat: 'repeat'\n              });\n            }; // delete path parameters from the params object so they do not end up in\n            // query\n\n\n            parameters.pathParams.forEach(function (param) {\n              delete params[param];\n            }); // if authClient is actually a string, use it as an API KEY\n\n            if (typeof authClient === 'string') {\n              params.key = params.key || authClient;\n              authClient = undefined;\n            }\n\n            if (parameters.mediaUrl && media.body) {\n              options.url = parameters.mediaUrl;\n\n              if (resource) {\n                // gaxios doesn't support multipart/related uploads, so it has to\n                // be implemented here.\n                params.uploadType = 'multipart';\n                multipart = [{\n                  'Content-Type': 'application/json',\n                  body: JSON.stringify(resource)\n                }, {\n                  'Content-Type': media.mimeType || resource && resource.mimeType || defaultMime,\n                  body: media.body // can be a readable stream or raw string!\n\n                }];\n                boundary = uuid.v4();\n                finale = \"--\".concat(boundary, \"--\");\n                rStream = new stream.PassThrough({\n                  flush: function flush(callback) {\n                    this.push('\\r\\n');\n                    this.push(finale);\n                    callback();\n                  }\n                });\n                pStream = new ProgressStream();\n                isStream = isReadableStream(multipart[1].body);\n                headers['Content-Type'] = \"multipart/related; boundary=\".concat(boundary);\n\n                for (_i = 0, _multipart = multipart; _i < _multipart.length; _i++) {\n                  part = _multipart[_i];\n                  preamble = \"--\".concat(boundary, \"\\r\\nContent-Type: \").concat(part['Content-Type'], \"\\r\\n\\r\\n\");\n                  rStream.push(preamble);\n\n                  if (typeof part.body === 'string') {\n                    rStream.push(part.body);\n                    rStream.push('\\r\\n');\n                  } else {\n                    // Gaxios does not natively support onUploadProgress in node.js.\n                    // Pipe through the pStream first to read the number of bytes read\n                    // for the purpose of tracking progress.\n                    pStream.on('progress', function (bytesRead) {\n                      if (options.onUploadProgress) {\n                        options.onUploadProgress({\n                          bytesRead: bytesRead\n                        });\n                      }\n                    });\n                    part.body.pipe(pStream).pipe(rStream);\n                  }\n                }\n\n                if (!isStream) {\n                  rStream.push(finale);\n                  rStream.push(null);\n                }\n\n                options.data = rStream;\n              } else {\n                params.uploadType = 'media';\n                Object.assign(headers, {\n                  'Content-Type': media.mimeType || defaultMime\n                });\n                options.data = media.body;\n              }\n            } else {\n              options.data = resource || undefined;\n            }\n\n            options.headers = headers;\n            options.params = params;\n\n            if (!isbrowser_1.isBrowser()) {\n              options.headers['Accept-Encoding'] = 'gzip';\n              directives = options.userAgentDirectives || [];\n              directives.push({\n                product: 'google-api-nodejs-client',\n                version: pkg.version,\n                comment: 'gzip'\n              });\n              userAgent = directives.map(function (d) {\n                var line = \"\".concat(d.product, \"/\").concat(d.version);\n\n                if (d.comment) {\n                  line += \" (\".concat(d.comment, \")\");\n                }\n\n                return line;\n              }).join(' ');\n              options.headers['User-Agent'] = userAgent;\n            } // By default gaxios treats any 2xx as valid, and all non 2xx status\n            // codes as errors.  This is a problem for HTTP 304s when used along\n            // with an eTag.\n\n\n            if (!options.validateStatus) {\n              options.validateStatus = function (status) {\n                return status >= 200 && status < 300 || status === 304;\n              };\n            } // Combine the GaxiosOptions options passed with this specific\n            // API call witht the global options configured at the API Context\n            // level, or at the global level.\n\n\n            mergedOptions = Object.assign({}, parameters.context.google ? parameters.context.google._options : {}, parameters.context._options, options);\n            delete mergedOptions.auth; // is overridden by our auth code\n            // Perform the HTTP request.  NOTE: this function used to return a\n            // mikeal/request object. Since the transition to Axios, the method is\n            // now void.  This may be a source of confusion for users upgrading from\n            // version 24.0 -> 25.0 or up.\n\n            if (!(authClient && typeof authClient === 'object')) {\n              _context.next = 34;\n              break;\n            }\n\n            return _context.abrupt(\"return\", authClient.request(mergedOptions));\n\n          case 34:\n            return _context.abrupt(\"return\", new google_auth_library_1.DefaultTransporter().request(mergedOptions));\n\n          case 35:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n/**\n * Basic Passthrough Stream that records the number of bytes read\n * every time the cursor is moved.\n */\n\n\nvar ProgressStream = /*#__PURE__*/function (_stream$Transform) {\n  _inherits(ProgressStream, _stream$Transform);\n\n  function ProgressStream() {\n    var _this;\n\n    _classCallCheck(this, ProgressStream);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ProgressStream).apply(this, arguments));\n    _this.bytesRead = 0;\n    return _this;\n  } // tslint:disable-next-line: no-any\n\n\n  _createClass(ProgressStream, [{\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, callback) {\n      this.bytesRead += chunk.length;\n      this.emit('progress', this.bytesRead);\n      this.push(chunk);\n      callback();\n    }\n  }]);\n\n  return ProgressStream;\n}(stream.Transform);","map":null,"metadata":{},"sourceType":"script"}